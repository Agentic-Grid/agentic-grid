# Task: [TASK_TITLE]
# Generated by PLANNER agent with executable specifications
# Template version: 2.0

id: TASK-XXX
feature_id: FEAT-XXX
title: "[Specific action with exact target - e.g., 'Implement POST /auth/login endpoint']"
agent: DISCOVERY | DESIGNER | DATA | BACKEND | FRONTEND | DEVOPS | QA
status: pending
priority: high | medium | low
type: enhancement | design | schema | implementation | automation | validation
phase: 1

# Timestamps
created_at: "[ISO8601 timestamp]"
updated_at: "[ISO8601 timestamp]"
started_at: null
completed_at: null

# =============================================================================
# CONTEXT (What the agent needs to understand)
# =============================================================================

context:
  # Project summary (2 lines max, ~50 tokens)
  project: |
    {Project Name}: {One sentence what it does}.
    Goal: {Primary goal from discovery}.

  # Feature summary (2 lines max, ~50 tokens)
  feature: |
    {Feature Name}: {One line description}.
    {Scope: what's included in this feature}.

  # Reference to full feature spec
  feature_spec: "plans/features/FEAT-XXX-{slug}/SPEC.md"

# =============================================================================
# SPECIFICATION (What exactly to build)
# =============================================================================
# This section contains EXECUTABLE SPECIFICATIONS - not vague requirements.
# Agents should be able to implement this without guessing.

specification:
  objective: |
    [Clear, detailed statement of exactly what this task produces]

  # ----- FOR DATA TASKS -----
  # schema:
  #   entities:
  #     - name: User
  #       table_name: users
  #       fields:
  #         - name: id
  #           type: uuid
  #           constraints: [primary_key, generated]
  #         - name: email
  #           type: varchar(255)
  #           constraints: [not_null, unique]
  #           validation: email
  #       indexes:
  #         - fields: [email]
  #           unique: true
  #       relationships:
  #         - name: sessions
  #           type: has_many
  #           target: Session
  #           foreign_key: user_id

  # ----- FOR BACKEND TASKS -----
  # endpoints:
  #   - method: POST
  #     path: /auth/login
  #     description: "Authenticate user and return JWT"
  #     auth_required: false
  #     request:
  #       body:
  #         email: { type: string, required: true, validation: email }
  #         password: { type: string, required: true, min_length: 8 }
  #     responses:
  #       200:
  #         body:
  #           token: { type: string, description: "JWT token" }
  #           user: { id: string, email: string, role: string }
  #       401:
  #         body:
  #           error: "Invalid email or password"
  #       429:
  #         body:
  #           error: "Too many login attempts"
  #           retry_after: { type: number }
  #     implementation:
  #       - Validate email format
  #       - Find user by email in database
  #       - Compare password using bcrypt
  #       - Generate JWT with { userId, role } payload, 24h expiry
  #       - Return token and user data

  # ----- FOR FRONTEND TASKS -----
  # components:
  #   - name: LoginForm
  #     description: "User login form with email/password"
  #     props:
  #       onSubmit: "(credentials: {email: string, password: string}) => Promise<void>"
  #       isLoading: boolean
  #       error: string | null
  #     state:
  #       email: string
  #       password: string
  #       touched: { email: boolean, password: boolean }
  #     validation:
  #       email: { required: true, pattern: email }
  #       password: { required: true, min_length: 8 }
  #     behavior:
  #       - Validate fields on blur
  #       - Disable submit when loading or invalid
  #       - Show error message when error prop is set
  #       - Clear error when user starts typing
  #     api_integration:
  #       endpoint: POST /api/auth/login
  #       on_success: "Call onSubmit prop with token"
  #       on_error: "Set error state with message"
  #     styling:
  #       - Use design tokens from contracts/design-tokens.yaml
  #       - Max width 400px, centered
  #       - Responsive: full width on mobile

  # ----- FOR DESIGNER TASKS -----
  # design:
  #   screens:
  #     - name: Login
  #       layout: Centered card on gradient background
  #       components:
  #         - Logo: 48px, centered
  #         - Form Card: max-width 400px, shadow-lg
  #         - Email Input: full width
  #         - Password Input: full width, with show/hide toggle
  #         - Submit Button: full width, primary color
  #         - Links: forgot password, register
  #       states:
  #         - idle: Form ready for input
  #         - loading: Submit button disabled with spinner
  #         - error: Red error message above form
  #       responsive:
  #         mobile: Full width with 16px padding
  #         tablet: 400px max width
  #         desktop: 400px max width

# =============================================================================
# FILES (What to create/modify)
# =============================================================================

files:
  create:
    - "[path/to/new/file.ts]"
  modify:
    - "[path/to/existing/file.ts]"

# =============================================================================
# DEPENDENCIES (What must exist first)
# =============================================================================

dependencies:
  # Tasks that must complete before this one
  tasks:
    - id: TASK-XXX
      provides: "[What that task provides that this task needs]"
      # Optional: verify command to check if dependency is met
      verify: "[Command or check to verify]"

  # Contract sections this task references
  contracts:
    - path: contracts/data-model.yaml
      section: "[Section of contract being used]"
    - path: contracts/api-contracts.yaml
      section: "[Endpoint being implemented]"

# =============================================================================
# EXPECTED RESULTS (How to verify completion)
# =============================================================================
# These are used by QA agent to validate the task.
# Each result must be TESTABLE - not vague.

expected_results:
  - description: "[What should be true when task is complete]"
    test: |
      [Exact command or steps to verify]
    expected: "[Expected output or behavior]"

  - description: "[Second verification point]"
    test: |
      [Verification command]
    expected: "[Expected result]"

# =============================================================================
# INTEGRATION (How this connects to other parts)
# =============================================================================

integration:
  # What this task provides to other tasks
  provides:
    - "[Exported function/component/endpoint]"
    - "[Type definition]"

  # What this task consumes from other tasks/contracts
  consumes:
    - source: "TASK-XXX"
      item: "[What is being used]"
    - source: "contracts/api-contracts.yaml"
      item: "[Endpoint definition]"

  # How to verify integration works
  integration_test: |
    [Steps to verify this task integrates properly with dependencies]

# =============================================================================
# METADATA
# =============================================================================

estimated_minutes: 120
actual_minutes: null

# Progress Log (append-only)
progress:
  - timestamp: "[ISO8601 timestamp]"
    agent: PLANNER
    action: created
    note: "Task created with executable specification"

# QA Validation
qa:
  required: true
  status: pending
  checklist: [] # Populated from expected_results
  notes: null

# =============================================================================
# TEMPLATE USAGE NOTES (delete this section when using)
# =============================================================================
#
# KEY PRINCIPLE: If an agent has to guess, the specification failed.
#
# SPECIFICATION SECTION:
#   This is the most important part. It must be EXACT:
#   - DATA tasks: Full schema with all fields, types, constraints
#   - BACKEND tasks: Full endpoint specs with request/response shapes
#   - FRONTEND tasks: Full component specs with props, state, behavior
#   - DESIGNER tasks: Full screen specs with layout, components, states
#
# EXPECTED RESULTS:
#   Each result must be VERIFIABLE:
#   - Bad: "Login should work"
#   - Good: "POST /api/auth/login with valid credentials returns 200 with JWT"
#
# INTEGRATION:
#   Explicitly state:
#   - What this task PROVIDES (exports, endpoints, types)
#   - What this task CONSUMES (from other tasks, contracts)
#   - How to VERIFY integration works
#
# AGENT TYPES:
#   DISCOVERY  - Requirements, user stories, specifications
#   DESIGNER   - UI/UX design, visual specs, design tokens
#   DATA       - Database schema, migrations, data models
#   BACKEND    - API endpoints, services, business logic
#   FRONTEND   - React components, hooks, pages
#   DEVOPS     - Docker, CI/CD, infrastructure, scripts
#   QA         - Testing, validation, acceptance criteria
#
# STATUS VALUES:
#   pending     - Not started
#   in_progress - Currently being worked on
#   blocked     - Waiting on dependency or issue
#   qa          - Implementation complete, awaiting validation
#   completed   - Done and validated
#
# =============================================================================
